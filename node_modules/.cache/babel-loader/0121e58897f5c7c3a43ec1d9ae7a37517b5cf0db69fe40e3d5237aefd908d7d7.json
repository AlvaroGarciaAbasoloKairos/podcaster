{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nconst toPodcastStorageKey = podcastId => `podcast:${podcastId}`;\nconst toPodcastUpdatedAtStorageKey = podcastId => `podcastUpdatedAt:${podcastId}`;\nconst usePodcast = _ref => {\n  _s();\n  let {\n    podcastId\n  } = _ref;\n  const [podcast, setPodcast] = useState(null);\n  const [loading, setLoading] = useState(null);\n  const fetchPodcast = useCallback(async () => {\n    if (!podcastId) return;\n    // Check if podcasts are already stored in localStorage\n    const storedPodcasts = localStorage.getItem(toPodcastStorageKey(podcastId));\n    const storedDate = Number(localStorage.getItem(toPodcastUpdatedAtStorageKey(podcastId)));\n    // If the podcasts have already been stored and no more than one day has passed, retrieve them from localStorage.\n    if (storedPodcasts && storedDate && Date.now() - storedDate < 86400000) {\n      setPodcast(JSON.parse(storedPodcasts));\n      setLoading(false);\n      return;\n    }\n    setLoading(true);\n    // Make request to get the updated list of podcasts.\n    try {\n      var _results$, _track$artistName, _track$artworkUrl, _track$artworkUrl2, _track$collectionId;\n      const encodedURL = encodeURIComponent(`https://itunes.apple.com/lookup?id=${podcastId}&media=podcast&entity=podcastEpisode&limit=20`);\n      const resp = await fetch(`https://api.allorigins.win/raw?url=${encodedURL}`);\n      const podcastResponse = await resp.json();\n      const {\n        results\n      } = podcastResponse;\n      const track = (_results$ = results[0]) !== null && _results$ !== void 0 ? _results$ : {};\n      const episodes = results.slice(1, results.length);\n      const description = episodes.length ? await getPodcastDescription(episodes[0].feedUrl) : undefined;\n      const _podcast = {\n        artistName: (_track$artistName = track.artistName) !== null && _track$artistName !== void 0 ? _track$artistName : '',\n        artworkUrl100: (_track$artworkUrl = track.artworkUrl100) !== null && _track$artworkUrl !== void 0 ? _track$artworkUrl : '',\n        artworkUrl600: (_track$artworkUrl2 = track.artworkUrl600) !== null && _track$artworkUrl2 !== void 0 ? _track$artworkUrl2 : '',\n        collectionId: (_track$collectionId = track.collectionId) !== null && _track$collectionId !== void 0 ? _track$collectionId : 0,\n        collectionName: track.collectionName,\n        description,\n        episodes: episodes.map(episode => {\n          var _episode$trackId, _episode$trackName, _episode$description, _episode$releaseDate, _episode$trackTimeMil, _episode$episodeUrl;\n          return {\n            id: (_episode$trackId = episode === null || episode === void 0 ? void 0 : episode.trackId) !== null && _episode$trackId !== void 0 ? _episode$trackId : '',\n            title: (_episode$trackName = episode === null || episode === void 0 ? void 0 : episode.trackName) !== null && _episode$trackName !== void 0 ? _episode$trackName : '',\n            description: episode !== null && episode !== void 0 && episode.shortDescription ? episode === null || episode === void 0 ? void 0 : episode.shortDescription : (_episode$description = episode === null || episode === void 0 ? void 0 : episode.description) !== null && _episode$description !== void 0 ? _episode$description : '',\n            pubDate: (_episode$releaseDate = episode === null || episode === void 0 ? void 0 : episode.releaseDate) !== null && _episode$releaseDate !== void 0 ? _episode$releaseDate : '',\n            duration: (_episode$trackTimeMil = episode === null || episode === void 0 ? void 0 : episode.trackTimeMillis) !== null && _episode$trackTimeMil !== void 0 ? _episode$trackTimeMil : '',\n            mediaContent: (_episode$episodeUrl = episode === null || episode === void 0 ? void 0 : episode.episodeUrl) !== null && _episode$episodeUrl !== void 0 ? _episode$episodeUrl : ''\n          };\n        })\n      };\n      setPodcast(_podcast);\n      localStorage.setItem(toPodcastStorageKey(podcastId), JSON.stringify(_podcast));\n      localStorage.setItem(toPodcastUpdatedAtStorageKey(podcastId), String(Date.now()));\n    } catch (err) {\n      console.trace(err);\n    } finally {\n      setLoading(false);\n    }\n  }, [podcastId]);\n  useEffect(() => {\n    fetchPodcast();\n  }, [fetchPodcast]);\n  return {\n    podcast,\n    loading\n  };\n};\n_s(usePodcast, \"L7L3f6rPwUNQMMt8FrYQdYoGGbY=\");\nasync function getPodcastDescription(url) {\n  try {\n    var _parsedData$querySele, _parsedData$querySele2;\n    const resp = await fetch(`https://api.allorigins.win/raw?url=${url}`);\n    const data = await resp.text();\n    const parsedData = new window.DOMParser().parseFromString(data !== null && data !== void 0 ? data : '', 'text/xml');\n    return (_parsedData$querySele = (_parsedData$querySele2 = parsedData.querySelector('description')) === null || _parsedData$querySele2 === void 0 ? void 0 : _parsedData$querySele2.textContent) !== null && _parsedData$querySele !== void 0 ? _parsedData$querySele : '';\n  } catch (err) {\n    console.trace(err);\n    return '';\n  }\n}\nexport default usePodcast;","map":{"version":3,"names":["useState","useEffect","useCallback","toPodcastStorageKey","podcastId","toPodcastUpdatedAtStorageKey","usePodcast","_ref","_s","podcast","setPodcast","loading","setLoading","fetchPodcast","storedPodcasts","localStorage","getItem","storedDate","Number","Date","now","JSON","parse","_results$","_track$artistName","_track$artworkUrl","_track$artworkUrl2","_track$collectionId","encodedURL","encodeURIComponent","resp","fetch","podcastResponse","json","results","track","episodes","slice","length","description","getPodcastDescription","feedUrl","undefined","_podcast","artistName","artworkUrl100","artworkUrl600","collectionId","collectionName","map","episode","_episode$trackId","_episode$trackName","_episode$description","_episode$releaseDate","_episode$trackTimeMil","_episode$episodeUrl","id","trackId","title","trackName","shortDescription","pubDate","releaseDate","duration","trackTimeMillis","mediaContent","episodeUrl","setItem","stringify","String","err","console","trace","url","_parsedData$querySele","_parsedData$querySele2","data","text","parsedData","window","DOMParser","parseFromString","querySelector","textContent"],"sources":["/Users/alvarokairosds/Repositorios/podcaster/src/lib/usePodcast.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\n\nconst toPodcastStorageKey = (podcastId: string) => `podcast:${podcastId}`;\nconst toPodcastUpdatedAtStorageKey = (podcastId: string) =>\n  `podcastUpdatedAt:${podcastId}`;\n\nexport interface Podcast {\n  artistName: string;\n  artworkUrl100: string;\n  artworkUrl600?: string;\n  collectionId: number;\n  collectionName: string;\n  description?: string;\n  episodes: PodcastEpisode[];\n}\n\nexport interface PodcastEpisode {\n  description: string;\n  duration: number;\n  id: number;\n  mediaContent: string;\n  pubDate: string;\n  title: string;\n}\n\ninterface PodcastTrack {\n  artistName: string;\n  artworkUrl100: string;\n  artworkUrl30: string;\n  artworkUrl60: string;\n  artworkUrl600: string;\n  collectionCensoredName: string;\n  collectionExplicitness: string;\n  collectionHdPrice: number;\n  collectionId: number;\n  collectionName: string;\n  collectionPrice: number;\n  collectionViewUrl: string;\n  contentAdvisoryRating: string;\n  country: string;\n  currency: string;\n  feedUrl: string;\n  genreIds: string[];\n  genres: string[];\n  kind: string;\n  primaryGenreName: string;\n  releaseDate: string;\n  trackCensoredName: string;\n  trackCount: number;\n  trackExplicitness: string;\n  trackId: number;\n  trackName: string;\n  trackPrice: number;\n  trackTimeMillis: number;\n  trackViewUrl: string;\n  wrapperType: string;\n}\n\ninterface PodcastEpisodeResponse {\n  artistIds: string[];\n  artworkUrl160: string | undefined;\n  artworkUrl60: string | undefined;\n  artworkUrl600: string | undefined;\n  closedCaptioning: string;\n  collectionId: number;\n  collectionName: string;\n  collectionViewUrl: string;\n  contentAdvisoryRating: string;\n  country: string;\n  description: string;\n  episodeContentType: string;\n  episodeFileExtension: string;\n  episodeGuid: string;\n  episodeUrl: string;\n  feedUrl: string;\n  genres: [\n    {\n      name: string;\n      id: string\n    }\n  ];\n  kind: string;\n  previewUrl: string | undefined;\n  releaseDate: string;\n  shortDescription: string;\n  trackId: number;\n  trackName: string;\n  trackTimeMillis: number | undefined;\n  trackViewUrl: string;\n  wrapperType: string;\n}\n\ninterface PodcastResponse {\n  resultCount: number;\n  results: [PodcastTrack, ...PodcastEpisodeResponse[]];\n}\n\ninterface Props {\n  podcastId?: string;\n}\n\nconst usePodcast = ({\n  podcastId,\n}: Props): {\n  podcast: Podcast | null;\n  loading: boolean | null;\n} => {\n  const [podcast, setPodcast] = useState<Podcast | null>(null);\n  const [loading, setLoading] = useState<boolean | null>(null);\n\n  const fetchPodcast = useCallback(async () => {\n    if (!podcastId) return;\n    // Check if podcasts are already stored in localStorage\n    const storedPodcasts = localStorage.getItem(toPodcastStorageKey(podcastId));\n    const storedDate = Number(\n      localStorage.getItem(toPodcastUpdatedAtStorageKey(podcastId)),\n    );\n    // If the podcasts have already been stored and no more than one day has passed, retrieve them from localStorage.\n    if (storedPodcasts && storedDate && Date.now() - storedDate < 86400000) {\n      setPodcast(JSON.parse(storedPodcasts));\n      setLoading(false);\n      return;\n    }\n    setLoading(true);\n    // Make request to get the updated list of podcasts.\n    try {\n      const encodedURL = encodeURIComponent(\n        `https://itunes.apple.com/lookup?id=${podcastId}&media=podcast&entity=podcastEpisode&limit=20`,\n      );\n      const resp = await fetch(\n        `https://api.allorigins.win/raw?url=${encodedURL}`,\n      );\n      const podcastResponse: PodcastResponse = await resp.json();\n      const { results } = podcastResponse;\n      const track = results[0] ?? {};\n      const episodes = results.slice(1, results.length) as PodcastEpisodeResponse[];\n      const description = episodes.length\n        ? await getPodcastDescription(episodes[0].feedUrl)\n        : undefined;\n      const _podcast: Podcast = {\n        artistName: track.artistName ?? '',\n        artworkUrl100: track.artworkUrl100 ?? '',\n        artworkUrl600: track.artworkUrl600 ?? '',\n        collectionId: track.collectionId ?? 0,\n        collectionName: track.collectionName,\n        description,\n        episodes: episodes.map((episode) => ({\n          id: episode?.trackId ?? '',\n          title: episode?.trackName ?? '',\n          description: episode?.shortDescription\n            ? episode?.shortDescription\n            : episode?.description ?? '',\n          pubDate: episode?.releaseDate ?? '',\n          duration: episode?.trackTimeMillis ?? '',\n          mediaContent: episode?.episodeUrl ?? '',\n        }) as PodcastEpisode),\n      };\n      setPodcast(_podcast);\n      localStorage.setItem(\n        toPodcastStorageKey(podcastId),\n        JSON.stringify(_podcast),\n      );\n      localStorage.setItem(\n        toPodcastUpdatedAtStorageKey(podcastId),\n        String(Date.now()),\n      );\n    } catch (err) {\n      console.trace(err);\n    } finally {\n      setLoading(false);\n    }\n  }, [podcastId]);\n\n  useEffect(() => {\n    fetchPodcast();\n  }, [fetchPodcast]);\n\n  return { podcast, loading };\n};\n\nasync function getPodcastDescription(url: string): Promise<string> {\n  try {\n    const resp = await fetch(`https://api.allorigins.win/raw?url=${url}`);\n    const data = await resp.text();\n    const parsedData = new window.DOMParser().parseFromString(\n      data ?? '',\n      'text/xml',\n    );\n    return parsedData.querySelector('description')?.textContent ?? '';\n  } catch (err) {\n    console.trace(err);\n    return '';\n  }\n}\n\nexport default usePodcast;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}